// atgateway inner protocol schema file v1

namespace atframe.gw.inner.v1;

enum error_code_t:int {
    EN_ECT_REFUSE_RECONNECT = -1005,
    EN_ECT_SESSION_EXPIRED = -1004,
    EN_ECT_BUSY = -1003,
    EN_ECT_HANDSHAKE = -1002,
    EN_ECT_FIRST_IDEL = -1001,
    EN_ECT_SUCCESS = 0,
}

enum rsa_sign_t : byte { 
    EN_RST_PKCS1 = 0, // PKCS#1
    EN_RST_PKCS1_V15, // PKCS#1 v1.5
    EN_RST_PSS        // PKCS#1 v2.1
}

enum handshake_step_t : byte { 
    EN_HST_START_REQ = 0,       // Step 1. start a new session handshake by client
    EN_HST_START_RSP,           // Step 2. tell client the session id, crypt method and bits, secret switch method and init data
    EN_HST_RECONNECT_REQ,       // Step 1. start a reconnect handshake by client, with session id, crypt method and bits and the encrypted secret code
    EN_HST_RECONNECT_RSP,       // Step 2. response reconnect handshake result to client
    EN_HST_DH_PUBKEY_REQ,       // Step 3. DH: send public key of client to server
    EN_HST_DH_PUBKEY_RSP,       // Step 4. DH: notify public key is accepted
    EN_HST_ECDH_PUBKEY_REQ,     // Step 3. ECDH: send public key of client to server
    EN_HST_ECDH_PUBKEY_RSP,     // Step 4. ECDH: notify public key is accepted
    EN_HST_RSA_SECRET_REQ,      // Step 3. send encrypted secert code generated by client to server
    EN_HST_RSA_SECRET_RSP,      // Step 4. notify secert code is accepted
    EN_HST_VERIFY,              // Step 5. validate the shared secret, send a encrypted public key to server
}

enum switch_secret_t : byte { 
    EN_SST_DIRECT = 0,          // direct send secret codes (deprecated)
    EN_SST_DH,                  // use DH algorithm to swicth secrets
    EN_SST_ECDH,                // use ECDH algorithm to switch secrets
    EN_SST_RSA                  // use RSA algorithm to switch secrets(not available now)
}

enum cs_msg_type_t : byte {
    EN_MTT_UNKNOWN = 0,
    EN_MTT_POST, 
    EN_MTT_HANDSHAKE,
    EN_MTT_PING,
    EN_MTT_PONG,
    EN_MTT_KICKOFF,
    EN_MTT_POST_KEY_SYN,
    EN_MTT_POST_KEY_ACK 
}

table cs_msg_head {
    type: cs_msg_type_t(id: 0);
    sequence: ulong(id: 1);
}
union cs_msg_body { cs_body_post, cs_body_kickoff, cs_body_ping, cs_body_handshake }

table cs_body_post {
    /// the length before encrypt, because encrypt data will pad data.
    length: ulong; 
    data: [byte];
}

table cs_body_kickoff {
    reason: int (id: 0);
}

table cs_body_rsa_cert {
    rsa_sign:rsa_sign_t (id: 0);
    hash_type:string (id: 1);
    pubkey:[byte] (id: 2);
}

///
/// crypt_param is used for different purpose depends on step and switch_type, that's
///     step=EN_HST_START_RSP, switch_type=EN_SST_DIRECT        : nothing
///     step=EN_HST_START_RSP, switch_type=EN_SST_DH            : DH Parameters: P,G,GX (GX means G^X and pub_key in openssl). KeyExchangeData as in SSL3
///     step=EN_HST_DH_PUBKEY_REQ, switch_type=EN_SST_DH        : DH public key of client
///     step=EN_HST_DH_PUBKEY_RSP, switch_type=EN_SST_DH        : verify data prefix
///     step=EN_HST_START_RSP, switch_type=EN_SST_DIRECT        : secret
///     step=EN_HST_START_RSP, switch_type=EN_SST_RSA           : salt
///     step=EN_HST_RSA_SECRET_REQ, switch_type=EN_SST_RSA      : encrypted secret
///     step=EN_HST_RSA_SECRET_RSP, switch_type=EN_SST_RSA      : nothing
///     step=EN_HST_VERIFY, switch_type=ANY                     : verify data prefix + suffix
table cs_body_handshake {
    session_id: ulong (id: 0);
    step: handshake_step_t (id: 1);
    switch_type: switch_secret_t (id: 2);
    crypt_type: string (id: 3);
    crypt_param: [byte] (id: 4); 
    rsa_cert: cs_body_rsa_cert (id: 5);
}

table cs_body_ping {
    /// the time when start ping
    timepoint: long (id: 0); 
}

/// message
table cs_msg {
    head: cs_msg_head (id: 0);
    body: cs_msg_body (id: 2);
}

root_type cs_msg;

file_identifier "ATGW";
file_extension "atgw";
