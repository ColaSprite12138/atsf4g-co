// atgateway inner protocol schema file v1

namespace atframe.gw.inner.v1;

enum error_code_t:int {
    EN_ECT_REFUSE_RECONNECT = -1005,
    EN_ECT_SESSION_EXPIRED = -1004,
    EN_ECT_BUSY = -1003,
    EN_ECT_HANDSHAKE = -1002,
    EN_ECT_FIRST_IDEL = -1001,
    EN_ECT_SUCCESS = 0,
}

enum crypt_type_t : byte { 
    EN_ET_NONE = 0, // no encrypt
    EN_ET_XTEA,     // xtea
    EN_ET_AES       // aes
}

enum rsa_sign_t : byte { 
    EN_RST_PKCS1 = 0, // PKCS#1
    EN_RST_PKCS1_V15, // PKCS#1 v1.5
    EN_RST_PSS        // PKCS#1 v2.1
}

enum hash_id_t : byte { 
    EN_HIT_MD5 = 0, // hash id: md5
    EN_HIT_SHA1,    // hash id: sha1
    EN_HIT_SHA256,  // hash id: sha256
    EN_HIT_SHA512   // hash id: sha512
}

enum handshake_step_t : byte { 
    EN_HST_START_REQ = 0,       // Step 1. start a new session handshake by client
    EN_HST_START_RSP,           // Step 2. tell client the session id, crypt method and bits, secret switch method and init data
    EN_HST_RECONNECT_REQ,       // Step 1. start a reconnect handshake by client, with session id, crypt method and bits, secret switch method and the encrypted secret code
    EN_HST_RECONNECT_RSP,       // Step 2. response reconnect handshake result to client
    EN_HST_DH_PUBKEY_REQ,       // Step 3. DH: send public key of client to server
    EN_HST_DH_PUBKEY_RSP,       // Step 4. DH: notify public key is accepted
    EN_HST_RSA_SECRET_REQ,      // Step 3. send encrypted secert code generated by client to server
    EN_HST_RSA_SECRET_RSP,      // Step 4. notify secert code is accepted
    EN_HST_VERIFY,              // Step 5. validate the shared secret, send a encrypted public key to server
}

enum switch_secret_t : byte { 
    EN_SST_DIRECT = 0,          // direct send secret codes (deprecated)
    EN_SST_DH,                  // use DH algorithm to swicth secrets
    EN_SST_RSA                  // use RSA algorithm to switch secrets(not available now)
}

enum cs_msg_type_t : byte {
    EN_MTT_UNKNOWN = 0,
    EN_MTT_POST, 
    EN_MTT_HANDSHAKE,
    EN_MTT_PING,
    EN_MTT_PONG,
    EN_MTT_KICKOFF,
    EN_MTT_POST_KEY_SYN,
    EN_MTT_POST_KEY_ACK 
}

table cs_msg_head {
    type: cs_msg_type_t(id: 0);
    sequence: ulong(id: 1);
}
union cs_msg_body { cs_body_post, cs_body_kickoff, cs_body_ping, cs_body_handshake }

table cs_body_post {
    /// the length before encrypt, because encrypt data will pad data.
    length: ulong; 
    data: [byte];
}

table cs_body_kickoff {
    reason: int (id: 0);
}

table cs_body_rsa_cert {
    rsa_sign:rsa_sign_t (id: 0);
    hash_type:hash_id_t (id: 1);
    pubkey:[byte] (id: 2);
}

///
/// crypt_param is used for different purpose depends on step and switch_type, that's
///     step=EN_HST_START_RSP, switch_type=EN_SST_DH : DH parameter
///     step=EN_HST_START_RSP, switch_type=EN_SST_DH : DH parameter
///     step=EN_HST_DH_PUBKEY_REQ, switch_type=EN_SST_DH : DH public key
///     step=EN_HST_DH_PUBKEY_RSP, switch_type=EN_SST_DH : nothing
///     step=EN_HST_START_RSP, switch_type=EN_SST_DIRECT: secret
///     step=EN_HST_START_RSP, switch_type=EN_SST_RSA: salt
///     step=EN_HST_RSA_SECRET_REQ, switch_type=EN_SST_RSA: encrypted secret
///     step=EN_HST_RSA_SECRET_RSP, switch_type=EN_SST_RSA: nothing
///     step=EN_HST_VERIFY, switch_type=ANY : any message just for test
table cs_body_handshake {
    session_id: [ulong] (id: 0);
    step: handshake_step_t (id: 1);
    switch_type: switch_secret_t (id: 2);
    crypt_type: crypt_type_t (id: 3);
    crypt_bits: [uint] (id: 4); 
    crypt_param: [byte] (id: 5); 
    rsa_cert: cs_body_rsa_cert (id: 6);
}

table cs_body_ping {
    /// the time when start ping
    timepoint: long (id: 0); 
}

/// message
table cs_msg {
    head: cs_msg_head (id: 0);
    body: cs_msg_body (id: 2);
}

root_type cs_msg;

file_identifier "ATGW";
file_extension "atgw";
