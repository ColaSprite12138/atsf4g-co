// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LIBATGWPROTOINNER_ATFRAME_GW_INNER_V1_H_
#define FLATBUFFERS_GENERATED_LIBATGWPROTOINNER_ATFRAME_GW_INNER_V1_H_

#include "flatbuffers/flatbuffers.h"

namespace atframe {
namespace gw {
namespace inner {
namespace v1 {

struct cs_msg_head;

struct cs_body_post;

struct cs_body_kickoff;

struct cs_body_rsa_cert;

struct cs_body_handshake;

struct cs_body_ping;

struct cs_msg;

enum error_code_t {
  error_code_t_EN_ECT_REFUSE_RECONNECT = -1005,
  error_code_t_EN_ECT_SESSION_EXPIRED = -1004,
  error_code_t_EN_ECT_BUSY = -1003,
  error_code_t_EN_ECT_HANDSHAKE = -1002,
  error_code_t_EN_ECT_FIRST_IDEL = -1001,
  error_code_t_EN_ECT_SUCCESS = 0,
  error_code_t_MIN = error_code_t_EN_ECT_REFUSE_RECONNECT,
  error_code_t_MAX = error_code_t_EN_ECT_SUCCESS
};

inline error_code_t (&EnumValueserror_code_t())[6] {
  static error_code_t values[] = {
    error_code_t_EN_ECT_REFUSE_RECONNECT,
    error_code_t_EN_ECT_SESSION_EXPIRED,
    error_code_t_EN_ECT_BUSY,
    error_code_t_EN_ECT_HANDSHAKE,
    error_code_t_EN_ECT_FIRST_IDEL,
    error_code_t_EN_ECT_SUCCESS
  };
  return values;
}

enum rsa_sign_t {
  rsa_sign_t_EN_RST_PKCS1 = 0,
  rsa_sign_t_EN_RST_PKCS1_V15 = 1,
  rsa_sign_t_EN_RST_PSS = 2,
  rsa_sign_t_MIN = rsa_sign_t_EN_RST_PKCS1,
  rsa_sign_t_MAX = rsa_sign_t_EN_RST_PSS
};

inline rsa_sign_t (&EnumValuesrsa_sign_t())[3] {
  static rsa_sign_t values[] = {
    rsa_sign_t_EN_RST_PKCS1,
    rsa_sign_t_EN_RST_PKCS1_V15,
    rsa_sign_t_EN_RST_PSS
  };
  return values;
}

inline const char **EnumNamesrsa_sign_t() {
  static const char *names[] = {
    "EN_RST_PKCS1",
    "EN_RST_PKCS1_V15",
    "EN_RST_PSS",
    nullptr
  };
  return names;
}

inline const char *EnumNamersa_sign_t(rsa_sign_t e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesrsa_sign_t()[index];
}

enum handshake_step_t {
  handshake_step_t_EN_HST_START_REQ = 0,
  handshake_step_t_EN_HST_START_RSP = 1,
  handshake_step_t_EN_HST_RECONNECT_REQ = 11,
  handshake_step_t_EN_HST_RECONNECT_RSP = 12,
  handshake_step_t_EN_HST_DH_PUBKEY_REQ = 21,
  handshake_step_t_EN_HST_DH_PUBKEY_RSP = 22,
  handshake_step_t_EN_HST_ECDH_PUBKEY_REQ = 31,
  handshake_step_t_EN_HST_ECDH_PUBKEY_RSP = 32,
  handshake_step_t_EN_HST_RSA_SECRET_REQ = 41,
  handshake_step_t_EN_HST_RSA_SECRET_RSP = 42,
  handshake_step_t_EN_HST_VERIFY = 101,
  handshake_step_t_MIN = handshake_step_t_EN_HST_START_REQ,
  handshake_step_t_MAX = handshake_step_t_EN_HST_VERIFY
};

inline handshake_step_t (&EnumValueshandshake_step_t())[11] {
  static handshake_step_t values[] = {
    handshake_step_t_EN_HST_START_REQ,
    handshake_step_t_EN_HST_START_RSP,
    handshake_step_t_EN_HST_RECONNECT_REQ,
    handshake_step_t_EN_HST_RECONNECT_RSP,
    handshake_step_t_EN_HST_DH_PUBKEY_REQ,
    handshake_step_t_EN_HST_DH_PUBKEY_RSP,
    handshake_step_t_EN_HST_ECDH_PUBKEY_REQ,
    handshake_step_t_EN_HST_ECDH_PUBKEY_RSP,
    handshake_step_t_EN_HST_RSA_SECRET_REQ,
    handshake_step_t_EN_HST_RSA_SECRET_RSP,
    handshake_step_t_EN_HST_VERIFY
  };
  return values;
}

enum switch_secret_t {
  switch_secret_t_EN_SST_DIRECT = 0,
  switch_secret_t_EN_SST_DH = 1,
  switch_secret_t_EN_SST_ECDH = 2,
  switch_secret_t_EN_SST_RSA = 3,
  switch_secret_t_MIN = switch_secret_t_EN_SST_DIRECT,
  switch_secret_t_MAX = switch_secret_t_EN_SST_RSA
};

inline switch_secret_t (&EnumValuesswitch_secret_t())[4] {
  static switch_secret_t values[] = {
    switch_secret_t_EN_SST_DIRECT,
    switch_secret_t_EN_SST_DH,
    switch_secret_t_EN_SST_ECDH,
    switch_secret_t_EN_SST_RSA
  };
  return values;
}

inline const char **EnumNamesswitch_secret_t() {
  static const char *names[] = {
    "EN_SST_DIRECT",
    "EN_SST_DH",
    "EN_SST_ECDH",
    "EN_SST_RSA",
    nullptr
  };
  return names;
}

inline const char *EnumNameswitch_secret_t(switch_secret_t e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesswitch_secret_t()[index];
}

enum cs_msg_type_t {
  cs_msg_type_t_EN_MTT_UNKNOWN = 0,
  cs_msg_type_t_EN_MTT_POST = 1,
  cs_msg_type_t_EN_MTT_HANDSHAKE = 2,
  cs_msg_type_t_EN_MTT_PING = 3,
  cs_msg_type_t_EN_MTT_PONG = 4,
  cs_msg_type_t_EN_MTT_KICKOFF = 5,
  cs_msg_type_t_EN_MTT_POST_KEY_SYN = 6,
  cs_msg_type_t_EN_MTT_POST_KEY_ACK = 7,
  cs_msg_type_t_MIN = cs_msg_type_t_EN_MTT_UNKNOWN,
  cs_msg_type_t_MAX = cs_msg_type_t_EN_MTT_POST_KEY_ACK
};

inline cs_msg_type_t (&EnumValuescs_msg_type_t())[8] {
  static cs_msg_type_t values[] = {
    cs_msg_type_t_EN_MTT_UNKNOWN,
    cs_msg_type_t_EN_MTT_POST,
    cs_msg_type_t_EN_MTT_HANDSHAKE,
    cs_msg_type_t_EN_MTT_PING,
    cs_msg_type_t_EN_MTT_PONG,
    cs_msg_type_t_EN_MTT_KICKOFF,
    cs_msg_type_t_EN_MTT_POST_KEY_SYN,
    cs_msg_type_t_EN_MTT_POST_KEY_ACK
  };
  return values;
}

inline const char **EnumNamescs_msg_type_t() {
  static const char *names[] = {
    "EN_MTT_UNKNOWN",
    "EN_MTT_POST",
    "EN_MTT_HANDSHAKE",
    "EN_MTT_PING",
    "EN_MTT_PONG",
    "EN_MTT_KICKOFF",
    "EN_MTT_POST_KEY_SYN",
    "EN_MTT_POST_KEY_ACK",
    nullptr
  };
  return names;
}

inline const char *EnumNamecs_msg_type_t(cs_msg_type_t e) {
  const size_t index = static_cast<int>(e);
  return EnumNamescs_msg_type_t()[index];
}

enum cs_msg_body {
  cs_msg_body_NONE = 0,
  cs_msg_body_cs_body_post = 1,
  cs_msg_body_cs_body_kickoff = 2,
  cs_msg_body_cs_body_ping = 3,
  cs_msg_body_cs_body_handshake = 4,
  cs_msg_body_MIN = cs_msg_body_NONE,
  cs_msg_body_MAX = cs_msg_body_cs_body_handshake
};

inline cs_msg_body (&EnumValuescs_msg_body())[5] {
  static cs_msg_body values[] = {
    cs_msg_body_NONE,
    cs_msg_body_cs_body_post,
    cs_msg_body_cs_body_kickoff,
    cs_msg_body_cs_body_ping,
    cs_msg_body_cs_body_handshake
  };
  return values;
}

inline const char **EnumNamescs_msg_body() {
  static const char *names[] = {
    "NONE",
    "cs_body_post",
    "cs_body_kickoff",
    "cs_body_ping",
    "cs_body_handshake",
    nullptr
  };
  return names;
}

inline const char *EnumNamecs_msg_body(cs_msg_body e) {
  const size_t index = static_cast<int>(e);
  return EnumNamescs_msg_body()[index];
}

template<typename T> struct cs_msg_bodyTraits {
  static const cs_msg_body enum_value = cs_msg_body_NONE;
};

template<> struct cs_msg_bodyTraits<cs_body_post> {
  static const cs_msg_body enum_value = cs_msg_body_cs_body_post;
};

template<> struct cs_msg_bodyTraits<cs_body_kickoff> {
  static const cs_msg_body enum_value = cs_msg_body_cs_body_kickoff;
};

template<> struct cs_msg_bodyTraits<cs_body_ping> {
  static const cs_msg_body enum_value = cs_msg_body_cs_body_ping;
};

template<> struct cs_msg_bodyTraits<cs_body_handshake> {
  static const cs_msg_body enum_value = cs_msg_body_cs_body_handshake;
};

bool Verifycs_msg_body(flatbuffers::Verifier &verifier, const void *obj, cs_msg_body type);
bool Verifycs_msg_bodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct cs_msg_head FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_SEQUENCE = 6
  };
  cs_msg_type_t type() const {
    return static_cast<cs_msg_type_t>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint64_t sequence() const {
    return GetField<uint64_t>(VT_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
};

struct cs_msg_headBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(cs_msg_type_t type) {
    fbb_.AddElement<uint8_t>(cs_msg_head::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_sequence(uint64_t sequence) {
    fbb_.AddElement<uint64_t>(cs_msg_head::VT_SEQUENCE, sequence, 0);
  }
  cs_msg_headBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_msg_headBuilder &operator=(const cs_msg_headBuilder &);
  flatbuffers::Offset<cs_msg_head> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<cs_msg_head>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_msg_head> Createcs_msg_head(
    flatbuffers::FlatBufferBuilder &_fbb,
    cs_msg_type_t type = cs_msg_type_t_EN_MTT_UNKNOWN,
    uint64_t sequence = 0) {
  cs_msg_headBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  builder_.add_type(type);
  return builder_.Finish();
}

struct cs_body_post FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LENGTH = 4,
    VT_DATA = 6
  };
  /// the length before encrypt, because encrypt data will pad data.
  uint64_t length() const {
    return GetField<uint64_t>(VT_LENGTH, 0);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct cs_body_postBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(uint64_t length) {
    fbb_.AddElement<uint64_t>(cs_body_post::VT_LENGTH, length, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(cs_body_post::VT_DATA, data);
  }
  cs_body_postBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_body_postBuilder &operator=(const cs_body_postBuilder &);
  flatbuffers::Offset<cs_body_post> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<cs_body_post>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_body_post> Createcs_body_post(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  cs_body_postBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<cs_body_post> Createcs_body_postDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t length = 0,
    const std::vector<int8_t> *data = nullptr) {
  return atframe::gw::inner::v1::Createcs_body_post(
      _fbb,
      length,
      data ? _fbb.CreateVector<int8_t>(*data) : 0);
}

struct cs_body_kickoff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REASON = 4
  };
  int32_t reason() const {
    return GetField<int32_t>(VT_REASON, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct cs_body_kickoffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(int32_t reason) {
    fbb_.AddElement<int32_t>(cs_body_kickoff::VT_REASON, reason, 0);
  }
  cs_body_kickoffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_body_kickoffBuilder &operator=(const cs_body_kickoffBuilder &);
  flatbuffers::Offset<cs_body_kickoff> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<cs_body_kickoff>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_body_kickoff> Createcs_body_kickoff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reason = 0) {
  cs_body_kickoffBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

struct cs_body_rsa_cert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RSA_SIGN = 4,
    VT_HASH_TYPE = 6,
    VT_PUBKEY = 8
  };
  rsa_sign_t rsa_sign() const {
    return static_cast<rsa_sign_t>(GetField<uint8_t>(VT_RSA_SIGN, 0));
  }
  const flatbuffers::String *hash_type() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH_TYPE);
  }
  const flatbuffers::Vector<int8_t> *pubkey() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PUBKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RSA_SIGN) &&
           VerifyOffset(verifier, VT_HASH_TYPE) &&
           verifier.Verify(hash_type()) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.Verify(pubkey()) &&
           verifier.EndTable();
  }
};

struct cs_body_rsa_certBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rsa_sign(rsa_sign_t rsa_sign) {
    fbb_.AddElement<uint8_t>(cs_body_rsa_cert::VT_RSA_SIGN, static_cast<uint8_t>(rsa_sign), 0);
  }
  void add_hash_type(flatbuffers::Offset<flatbuffers::String> hash_type) {
    fbb_.AddOffset(cs_body_rsa_cert::VT_HASH_TYPE, hash_type);
  }
  void add_pubkey(flatbuffers::Offset<flatbuffers::Vector<int8_t>> pubkey) {
    fbb_.AddOffset(cs_body_rsa_cert::VT_PUBKEY, pubkey);
  }
  cs_body_rsa_certBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_body_rsa_certBuilder &operator=(const cs_body_rsa_certBuilder &);
  flatbuffers::Offset<cs_body_rsa_cert> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<cs_body_rsa_cert>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_body_rsa_cert> Createcs_body_rsa_cert(
    flatbuffers::FlatBufferBuilder &_fbb,
    rsa_sign_t rsa_sign = rsa_sign_t_EN_RST_PKCS1,
    flatbuffers::Offset<flatbuffers::String> hash_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> pubkey = 0) {
  cs_body_rsa_certBuilder builder_(_fbb);
  builder_.add_pubkey(pubkey);
  builder_.add_hash_type(hash_type);
  builder_.add_rsa_sign(rsa_sign);
  return builder_.Finish();
}

inline flatbuffers::Offset<cs_body_rsa_cert> Createcs_body_rsa_certDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rsa_sign_t rsa_sign = rsa_sign_t_EN_RST_PKCS1,
    const char *hash_type = nullptr,
    const std::vector<int8_t> *pubkey = nullptr) {
  return atframe::gw::inner::v1::Createcs_body_rsa_cert(
      _fbb,
      rsa_sign,
      hash_type ? _fbb.CreateString(hash_type) : 0,
      pubkey ? _fbb.CreateVector<int8_t>(*pubkey) : 0);
}

///
/// crypt_param is used for different purpose depends on step and switch_type, that's
///     step=EN_HST_START_RSP, switch_type=EN_SST_DIRECT        : nothing
///     step=EN_HST_START_RSP, switch_type=EN_SST_DH            : DH Parameters: P,G,GX (GX means G^X and pub_key in openssl). KeyExchangeData as in SSL3
///     step=EN_HST_DH_PUBKEY_REQ, switch_type=EN_SST_DH        : DH public key of client
///     step=EN_HST_DH_PUBKEY_RSP, switch_type=EN_SST_DH        : verify data prefix
///     step=EN_HST_START_RSP, switch_type=EN_SST_DIRECT        : secret
///     step=EN_HST_START_RSP, switch_type=EN_SST_RSA           : salt
///     step=EN_HST_RSA_SECRET_REQ, switch_type=EN_SST_RSA      : encrypted secret
///     step=EN_HST_RSA_SECRET_RSP, switch_type=EN_SST_RSA      : nothing
///     step=EN_HST_VERIFY, switch_type=ANY                     : verify data prefix + suffix
struct cs_body_handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SESSION_ID = 4,
    VT_STEP = 6,
    VT_SWITCH_TYPE = 8,
    VT_CRYPT_TYPE = 10,
    VT_CRYPT_PARAM = 12,
    VT_RSA_CERT = 14
  };
  uint64_t session_id() const {
    return GetField<uint64_t>(VT_SESSION_ID, 0);
  }
  handshake_step_t step() const {
    return static_cast<handshake_step_t>(GetField<uint8_t>(VT_STEP, 0));
  }
  switch_secret_t switch_type() const {
    return static_cast<switch_secret_t>(GetField<uint8_t>(VT_SWITCH_TYPE, 0));
  }
  const flatbuffers::String *crypt_type() const {
    return GetPointer<const flatbuffers::String *>(VT_CRYPT_TYPE);
  }
  const flatbuffers::Vector<int8_t> *crypt_param() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_CRYPT_PARAM);
  }
  const cs_body_rsa_cert *rsa_cert() const {
    return GetPointer<const cs_body_rsa_cert *>(VT_RSA_CERT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SESSION_ID) &&
           VerifyField<uint8_t>(verifier, VT_STEP) &&
           VerifyField<uint8_t>(verifier, VT_SWITCH_TYPE) &&
           VerifyOffset(verifier, VT_CRYPT_TYPE) &&
           verifier.Verify(crypt_type()) &&
           VerifyOffset(verifier, VT_CRYPT_PARAM) &&
           verifier.Verify(crypt_param()) &&
           VerifyOffset(verifier, VT_RSA_CERT) &&
           verifier.VerifyTable(rsa_cert()) &&
           verifier.EndTable();
  }
};

struct cs_body_handshakeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(uint64_t session_id) {
    fbb_.AddElement<uint64_t>(cs_body_handshake::VT_SESSION_ID, session_id, 0);
  }
  void add_step(handshake_step_t step) {
    fbb_.AddElement<uint8_t>(cs_body_handshake::VT_STEP, static_cast<uint8_t>(step), 0);
  }
  void add_switch_type(switch_secret_t switch_type) {
    fbb_.AddElement<uint8_t>(cs_body_handshake::VT_SWITCH_TYPE, static_cast<uint8_t>(switch_type), 0);
  }
  void add_crypt_type(flatbuffers::Offset<flatbuffers::String> crypt_type) {
    fbb_.AddOffset(cs_body_handshake::VT_CRYPT_TYPE, crypt_type);
  }
  void add_crypt_param(flatbuffers::Offset<flatbuffers::Vector<int8_t>> crypt_param) {
    fbb_.AddOffset(cs_body_handshake::VT_CRYPT_PARAM, crypt_param);
  }
  void add_rsa_cert(flatbuffers::Offset<cs_body_rsa_cert> rsa_cert) {
    fbb_.AddOffset(cs_body_handshake::VT_RSA_CERT, rsa_cert);
  }
  cs_body_handshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_body_handshakeBuilder &operator=(const cs_body_handshakeBuilder &);
  flatbuffers::Offset<cs_body_handshake> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<cs_body_handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_body_handshake> Createcs_body_handshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t session_id = 0,
    handshake_step_t step = handshake_step_t_EN_HST_START_REQ,
    switch_secret_t switch_type = switch_secret_t_EN_SST_DIRECT,
    flatbuffers::Offset<flatbuffers::String> crypt_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> crypt_param = 0,
    flatbuffers::Offset<cs_body_rsa_cert> rsa_cert = 0) {
  cs_body_handshakeBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_rsa_cert(rsa_cert);
  builder_.add_crypt_param(crypt_param);
  builder_.add_crypt_type(crypt_type);
  builder_.add_switch_type(switch_type);
  builder_.add_step(step);
  return builder_.Finish();
}

inline flatbuffers::Offset<cs_body_handshake> Createcs_body_handshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t session_id = 0,
    handshake_step_t step = handshake_step_t_EN_HST_START_REQ,
    switch_secret_t switch_type = switch_secret_t_EN_SST_DIRECT,
    const char *crypt_type = nullptr,
    const std::vector<int8_t> *crypt_param = nullptr,
    flatbuffers::Offset<cs_body_rsa_cert> rsa_cert = 0) {
  return atframe::gw::inner::v1::Createcs_body_handshake(
      _fbb,
      session_id,
      step,
      switch_type,
      crypt_type ? _fbb.CreateString(crypt_type) : 0,
      crypt_param ? _fbb.CreateVector<int8_t>(*crypt_param) : 0,
      rsa_cert);
}

struct cs_body_ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMEPOINT = 4
  };
  /// the time when start ping
  int64_t timepoint() const {
    return GetField<int64_t>(VT_TIMEPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMEPOINT) &&
           verifier.EndTable();
  }
};

struct cs_body_pingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timepoint(int64_t timepoint) {
    fbb_.AddElement<int64_t>(cs_body_ping::VT_TIMEPOINT, timepoint, 0);
  }
  cs_body_pingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_body_pingBuilder &operator=(const cs_body_pingBuilder &);
  flatbuffers::Offset<cs_body_ping> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<cs_body_ping>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_body_ping> Createcs_body_ping(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timepoint = 0) {
  cs_body_pingBuilder builder_(_fbb);
  builder_.add_timepoint(timepoint);
  return builder_.Finish();
}

/// message
struct cs_msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEAD = 4,
    VT_BODY_TYPE = 6,
    VT_BODY = 8
  };
  const cs_msg_head *head() const {
    return GetPointer<const cs_msg_head *>(VT_HEAD);
  }
  cs_msg_body body_type() const {
    return static_cast<cs_msg_body>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const cs_body_post *body_as_cs_body_post() const {
    return body_type() == cs_msg_body_cs_body_post ? static_cast<const cs_body_post *>(body()) : nullptr;
  }
  const cs_body_kickoff *body_as_cs_body_kickoff() const {
    return body_type() == cs_msg_body_cs_body_kickoff ? static_cast<const cs_body_kickoff *>(body()) : nullptr;
  }
  const cs_body_ping *body_as_cs_body_ping() const {
    return body_type() == cs_msg_body_cs_body_ping ? static_cast<const cs_body_ping *>(body()) : nullptr;
  }
  const cs_body_handshake *body_as_cs_body_handshake() const {
    return body_type() == cs_msg_body_cs_body_handshake ? static_cast<const cs_body_handshake *>(body()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEAD) &&
           verifier.VerifyTable(head()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE) &&
           VerifyOffset(verifier, VT_BODY) &&
           Verifycs_msg_body(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const cs_body_post *cs_msg::body_as<cs_body_post>() const {
  return body_as_cs_body_post();
}

template<> inline const cs_body_kickoff *cs_msg::body_as<cs_body_kickoff>() const {
  return body_as_cs_body_kickoff();
}

template<> inline const cs_body_ping *cs_msg::body_as<cs_body_ping>() const {
  return body_as_cs_body_ping();
}

template<> inline const cs_body_handshake *cs_msg::body_as<cs_body_handshake>() const {
  return body_as_cs_body_handshake();
}

struct cs_msgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_head(flatbuffers::Offset<cs_msg_head> head) {
    fbb_.AddOffset(cs_msg::VT_HEAD, head);
  }
  void add_body_type(cs_msg_body body_type) {
    fbb_.AddElement<uint8_t>(cs_msg::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(flatbuffers::Offset<void> body) {
    fbb_.AddOffset(cs_msg::VT_BODY, body);
  }
  cs_msgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cs_msgBuilder &operator=(const cs_msgBuilder &);
  flatbuffers::Offset<cs_msg> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<cs_msg>(end);
    return o;
  }
};

inline flatbuffers::Offset<cs_msg> Createcs_msg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<cs_msg_head> head = 0,
    cs_msg_body body_type = cs_msg_body_NONE,
    flatbuffers::Offset<void> body = 0) {
  cs_msgBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_head(head);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

inline bool Verifycs_msg_body(flatbuffers::Verifier &verifier, const void *obj, cs_msg_body type) {
  switch (type) {
    case cs_msg_body_NONE: {
      return true;
    }
    case cs_msg_body_cs_body_post: {
      auto ptr = reinterpret_cast<const cs_body_post *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case cs_msg_body_cs_body_kickoff: {
      auto ptr = reinterpret_cast<const cs_body_kickoff *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case cs_msg_body_cs_body_ping: {
      auto ptr = reinterpret_cast<const cs_body_ping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case cs_msg_body_cs_body_handshake: {
      auto ptr = reinterpret_cast<const cs_body_handshake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifycs_msg_bodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifycs_msg_body(
        verifier,  values->Get(i), types->GetEnum<cs_msg_body>(i))) {
      return false;
    }
  }
  return true;
}

inline const atframe::gw::inner::v1::cs_msg *Getcs_msg(const void *buf) {
  return flatbuffers::GetRoot<atframe::gw::inner::v1::cs_msg>(buf);
}

inline const char *cs_msgIdentifier() {
  return "ATGW";
}

inline bool cs_msgBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, cs_msgIdentifier());
}

inline bool Verifycs_msgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<atframe::gw::inner::v1::cs_msg>(cs_msgIdentifier());
}

inline const char *cs_msgExtension() {
  return "atgw";
}

inline void Finishcs_msgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<atframe::gw::inner::v1::cs_msg> root) {
  fbb.Finish(root, cs_msgIdentifier());
}

}  // namespace v1
}  // namespace inner
}  // namespace gw
}  // namespace atframe

#endif  // FLATBUFFERS_GENERATED_LIBATGWPROTOINNER_ATFRAME_GW_INNER_V1_H_
